#!/usr/bin/python3
# coding: utf-8
#
# A simple indicator applet displaying cpu and memory information
#
# Author: Alex Eftimie <alex@eftimie.ro>
# Fork Author: fossfreedom <foss.freedom@gmail.com>
# Original Homepage: http://launchpad.net/indicator-sysmonitor
# Fork Homepage: https://github.com/fossfreedom/indicator-sysmonitor
# License: GPL v3
#
from gettext import gettext as _
from gettext import textdomain, bindtextdomain
import sys
import os
import json
from threading import Event
from gi.repository import AppIndicator3 as appindicator
import logging
import tempfile
from gi.repository import Gtk, GLib
from preferences import Preferences
from preferences import VERSION
from sensors import StatusFetcher
from sensors import settings
from sensors import Sensor


textdomain("indicator-sysmonitor")
bindtextdomain("indicator-sysmonitor", "./lang")

GLib.threads_init()
logging.basicConfig(file=sys.stderr, level=logging.INFO)

class IndicatorSysmonitor(object):
    SETTINGS_FILE = os.getenv("HOME") + '/.indicator-sysmonitor.json'
    SENSORS_DISABLED = False

    def __init__(self):
        self._preferences_dialog = None
        self._help_dialog = None
        self._fetcher = StatusFetcher(self)
        self.alive = Event()

        fn, self.tindicator = tempfile.mkstemp(suffix=".svg")

        with open(self.tindicator, "w") as f:
            svg = '<?xml version="1.0" encoding="UTF-8" \
                        standalone="no"?><svg id="empty" xmlns="http://www.w3.org/2000/svg" \
                        height="22" width="1" version="1.0" \
                        xmlns:xlink="http://www.w3.org/1999/xlink"></svg>'
            f.write(svg)
            f.close()

        self.ind = appindicator.Indicator.new("indicator-sysmonitor", self.tindicator, \
                                              appindicator.IndicatorCategory.SYSTEM_SERVICES)
        self.ind.set_ordering_index(0)

        self.ind.set_status(appindicator.IndicatorStatus.ACTIVE)
        self.ind.set_label("Init...", "")

        self._create_menu()
        self.load_settings()
        self.alive.set()
        self._fetcher.start()
        logging.info("Fetcher started")

    def _create_menu(self):
        """Creates the main menu and shows it."""
        # create menu {{{
        menu = Gtk.Menu()
        # add System Monitor menu item
        full_sysmon = Gtk.MenuItem(_('System Monitor'))
        full_sysmon.connect('activate', self.on_full_sysmon_activated)
        menu.add(full_sysmon)
        menu.add(Gtk.SeparatorMenuItem())

        # add preferences menu item
        pref_menu = Gtk.MenuItem(_('Preferences'))
        pref_menu.connect('activate', self.on_preferences_activated)
        menu.add(pref_menu)

        # add help menu item
        help_menu = Gtk.MenuItem(_('Help'))
        help_menu.connect('activate', self._on_help)
        menu.add(help_menu)

        # add preference menu item
        exit_menu = Gtk.MenuItem(_('Quit'))
        exit_menu.connect('activate', self.on_exit)
        menu.add(exit_menu)

        menu.show_all()
        self.ind.set_menu(menu)
        logging.info("Menu shown")
        # }}} menu done!

    def update_indicator_guide(self):
        """Updates the label guide from appindicator."""
        data = self._fetcher.fetch()
        for key in data:
            if key.startswith('fs'):
                data[key] = '000gB'
                break

        data['mem'] = data['cpu'] = data['bat'] = '000%'
        data['net'] = '↓666kB/s ↑666kB/s'

        guide = settings['custom_text'].format(**data)
        self.ind.set_property("label-guide", guide)

    def update(self, data):
        """It updates the appindicator text with the the values
        from data"""
        try:
            label = settings["custom_text"].format(**data) if len(data) \
                else _("(no output)")

        except KeyError as ex:
            label = _("Invalid Sensor: {}").format(ex)
        except Exception as ex:
            logging.exception(ex)
            label = _("Unknown error: ").format(ex)

        self.ind.set_label(label, "")
        self.ind.set_title(label)
        # print (label)

    def load_settings(self):
        """It gets the settings from the config file and
        sets them to the correct vars"""
        try:
            with open(IndicatorSysmonitor.SETTINGS_FILE, 'r') as f:
                cfg = json.load(f)

            if cfg['custom_text'] is not None:
                settings['custom_text'] = cfg['custom_text']
            if cfg['interval'] is not None:
                settings['interval'] = cfg['interval']
            if cfg['on_startup'] is not None:
                settings['on_startup'] = cfg['on_startup']
            if cfg['sensors'] is not None:
                settings['sensors'] = cfg['sensors']

            Sensor.update_regex()
            self.update_indicator_guide()

        except Exception as ex:
            logging.exception(ex)
            logging.error('Reading settings failed')

    @staticmethod
    def save_settings():
        """It stores the current settings to the config file."""
        # TODO: use gsettings
        try:
            with open(IndicatorSysmonitor.SETTINGS_FILE, 'w') as f:
                f.write(json.dumps(settings))

        except Exception as ex:
            logging.exception(ex)
            logging.error('Writing settings failed')

    # actions raised from menu
    def on_preferences_activated(self, event=None):
        """Raises the preferences dialog. If it's already open, it's
        focused"""
        if self._preferences_dialog is not None:
            self._preferences_dialog.present()
            return

        self._preferences_dialog = Preferences(self)
        self._preferences_dialog.run()
        self._preferences_dialog = None

    def on_full_sysmon_activated(self, event=None):
        os.system('gnome-system-monitor &')

    def on_exit(self, event=None, data=None):
        """Action call when the main programs is closed."""
        # cleanup temporary indicator icon
        os.remove(self.tindicator)
        # close the open dialogs
        if self._help_dialog is not None:
            self._help_dialog.destroy()

        if self._preferences_dialog is not None:
            self._preferences_dialog.destroy()

        logging.info("Terminated")
        self.alive.clear()
        try:
            Gtk.main_quit()
        except RuntimeError:
            pass

    def _on_help(self, event=None, data=None):
        """Raise a dialog with info about the app."""
        if self._help_dialog is not None:
            self._help_dialog.present()
            return

        self._help_dialog = Gtk.MessageDialog(
            None, Gtk.DialogFlags.DESTROY_WITH_PARENT, Gtk.MessageType.INFO,
            Gtk.ButtonsType.OK, None)

        self._help_dialog.set_title(_("Help"))
        self._help_dialog.set_markup(HELP_MSG)
        self._help_dialog.run()
        self._help_dialog.destroy()
        self._help_dialog = None


from optparse import OptionParser  # TODO: optparse is deprecated

if __name__ == "__main__":
    parser = OptionParser("usage: %prog [options]", version="%prog " + VERSION)
    parser.add_option("--config", "", default=None,
                      help=_("Use custom config file."))

    (options, args) = parser.parse_args()

    if options.config:
        if not os.path.exists(options.config):
            logging.error(_("{} does not exist!").format(options.config))
            sys.exit(-1)
        logging.info(_("Using config file: {}").format(options.config))
        IndicatorSysmonitor.SETTINGS_FILE = options.config

    if not os.path.exists(IndicatorSysmonitor.SETTINGS_FILE):
        IndicatorSysmonitor.save_settings()

    # setup an instance with config
    app = IndicatorSysmonitor()
    try:
        Gtk.main()
    except KeyboardInterrupt:
        app.on_exit()
